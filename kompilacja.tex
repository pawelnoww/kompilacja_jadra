\documentclass[12pt]{report}
\usepackage{polski}
\usepackage{float}

% interlinia
\linespread{1.25}

% marginesy
\usepackage{geometry}
\newgeometry{tmargin=3cm, bmargin=3cm, lmargin=2.5cm, rmargin=2.5cm}

% rysunki
\usepackage{graphicx}
\graphicspath{{figures/}}


% Title Page
\title{Kompilacja jądra}
\author{Paweł Nowak}

% listing
\usepackage{listings}


\begin{document}
\maketitle


\chapter{Pobieranie ostatniej stabilnej wersji jądra}
Została sprawdzona wersja jądra z użyciem komendy \verb|uname --release|. W systemie znajdowało się jądro w wersji \verb|5.15-27-smp|. Korzystając z witryny \verb*|www.kernel.org| sprawdzono najnowszą stabilną wersję jądra (\verb|5.18.3|).
\begin{figure}[H]
	\centering
	\includegraphics[width=12cm]{1_1}
	\caption{Informacje o jądrze systemu}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=12cm]{1_1_2}
	\caption{Fragment witryny www.kernel.org}
\end{figure}

Pobrano najnowszą wersję jądra, uprzednio wchodząc do katalogu \verb|/usr/src|
\begin{figure}[H]
	\centering
	\includegraphics[width=15cm]{1_2}
	\caption{Pobieranie jądra systemu w wersji 5.18.3}
\end{figure}

Rozpakowano pobrane archiwum z użyciem komendy \verb*|tar -xpf linux-5.18.3.tar.xz|
\begin{figure}[H]
	\centering
	\includegraphics[width=15cm]{1_3}
	\caption{Rozpakowywanie archiwum z pobranym jądrem systemu}
\end{figure}


\chapter{Przebieg procesu kompilacji dla starej metody}

Po wejściu w katalog \verb*|linux-5.18.3| wykonano kopię konfiguracji starego jądra. W tym celu wykorzystano komendę \verb*|zcat /proc/config.gz > .config|. Rezultat komendy \verb*|ls -la| potwierdza poprawne skopiowanie pliku konfiguracyjnego (zaznaczono plik na zrzucie ekranu).
\begin{figure}[H]
	\centering
	\includegraphics[width=15cm]{2_1}
	\caption{Kopiowanie pliku konfiguracyjnego}
\end{figure}

Następnie z użyciem komendy \verb*|make localmodconfig| przygotowano plik konfiguracyjny. W każdym pojawiającym się komunikacie ustawiono wartość domyślną danego parametru klikając klawisz \verb*|ENTER|.
\begin{figure}[H]
	\centering
	\includegraphics[width=15cm]{2_2}
	\caption{Rezultat komendy przygotowującej plik konfiguracyjny}
\end{figure}

Przystąpiono do procesu kompilacji jądra. Wykorzystano komendę \verb*|make -j4 bzImage|.
\begin{figure}[H]
	\centering
	\includegraphics[width=15cm]{2_3}
	\caption{Wywołanie komendy rozpoczynającej proces kompilacji jądra}
\end{figure}

Po około 15 minutach proces kompilacji jądra zakończył się pomyślnie. Na standardowym wyjściu widnieje ścieżka do obrazu jądra: \verb*|arch/x86/boot/bzImage|.
\begin{figure}[H]
	\centering
	\includegraphics[width=15cm]{2_4}
	\caption{Końcowy rezultat komendy wywołującej proces kompilacji jądra}
\end{figure}

Kolejno zbudowano moduły jądra. Wywołano komendę \verb*|make -j4 modules|.

\begin{figure}[H]
	\centering
	\includegraphics[width=15cm]{2_5}
	\caption{Wywołanie komendy budującej modułów jądra}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=15cm]{2_6}
	\caption{Końcowy rezultat komendy budującej moduły jądra}
\end{figure}

Proces zakończył się pomyślnie po około 2 minutach. Kolejno przystąpiono do procesu instalacji modułów, co wykonano z pomocą komendy \verb*|make -j4 modules install|.

\begin{figure}[H]
	\centering
	\includegraphics[width=15cm]{2_7}
	\caption{Instalacja modułów}
\end{figure}

Kolejnym etapem było kopiowanie plików nowego jądra do katalogu boot z użyciem poniższych komend:
\begin{itemize}
	\item obraz jądra: \verb*|cp arch/x86/boot/bzImage /boot/vmlinuz-method1-5.18.3-smp|
	\item plik konfiguracyjny: \verb*|cp .config /boot/config-method1-5.18.3-smp|
	\item tablica symboli: \verb*|cp System.map /boot/System.map-method1-5.18.3-smp|
\end{itemize}
gdzie \verb*|method1| jest oznaczeniem aktualnie wykonywanej metody kompilacji jądra, a \verb*|5.18.3-smp| wersją jądra.

\begin{figure}[H]
	\centering
	\includegraphics[width=15cm]{2_8}
	\caption{Kopiowanie plików jądra do katalogu boot}
\end{figure}

Kolejnym etapem jest utworzenie linku symbolicznego: do pliku \verb*|System.map| z katalogu \verb*|/boot| należy dołączyć uprzednio skopiowany plik \verb*|System.map-method1-5.18.3-smp|.

\begin{figure}[H]
	\centering
	\includegraphics[width=15cm]{2_9}
	\caption{Tworzenie symbolicznego linku do pliku System.map}
\end{figure}

W celu skonfigurowania RAMDISK, z użyciem skryptu \verb*|mkinitrd_command_generator.sh| wygenerowano stosowną komendę, którą później wykonano: \\
 \verb*|mkinitrd -c -k 5.18.3-smp -f ext4 -r /dev/sda1 -m ext4 -u -o /boot/initrd.gz|.
 W komendzie zmieniono nazwę pliku wyjściowego na taką, która zachowa spójność z poprzednio skopiowanymi plikami jądra.
 \begin{figure}[H]
 	\centering
 	\includegraphics[width=15cm]{2_10}
 	\caption{Tworzenie RAMDISK}
 \end{figure}
 
 Następnie wykonano konfiguracją bootloadera \verb*|LILO|. W tym celu edytowano plik konfiguracyjny \verb*|/etc/lilo.conf| zamieszczając w nim nowy wpis.
  \begin{figure}[H]
  	\centering
  	\includegraphics[width=15cm]{2_11}
  	\caption{Edycja lilo.conf}
  \end{figure}
  Zmiany wprowadzone do pliku konfiguracyjnego zostały zatwierdzone poprzez wywołanie komendy \verb*|lilo|:
    \begin{figure}[H]
    	\centering
    	\includegraphics[width=15cm]{2_12}
    	\caption{Wywołanie komendy lilo}
    \end{figure}
    
    Po zrestartowaniu systemu w boot menu pojawiła się opcja \verb*|method1|. System pomyślnie uruchomił się oraz pomyślnie zalogowano się na użytkownika \verb*|root|.
    
    \begin{figure}[H]
       	\centering
       	\includegraphics[width=15cm]{2_13}
       	\caption{Boot menu po restarcie systemu}
    \end{figure}
        
    \begin{figure}[H]
          	\centering
          	\includegraphics[width=15cm]{2_14}
          	\caption{Pomyślne logowanie oraz start systemu}
    \end{figure}
    
    Po sprawdzeniu wersji jądra otrzymano rezultat \verb*|5.18.3-smp| zgodny z oczekiwaniami.
    \begin{figure}[H]
         	\centering
         	\includegraphics[width=15cm]{2_15}
         	\caption{Aktualna wersja jądra}
    \end{figure}
    
    Archiwum ze zmodyfikowanymi plikami jądra zostało spakowane oraz przeniesione z użyciem następujących komend:
    \\ \noindent
    \verb*|zip -r method1.zip linux-5.18.3/| \\
    \verb*|scp -P 22 root@192.168.56.101:/usr/src/method1.zip .|
    


\chapter{Przebieg procesu kompilacji dla nowej metody}

Rozpoczęto pracę na wcześniej przygotowanym archiwum z jądrem systemu Linux. Postępowano zgodnie z zaleceniami zamieszczonymi w pliku \verb*|srcipts/kconfig/streamline_config.pl|:

\begin{lstlisting}[basicstyle=\tiny]
# Howto:
#
#  1. Boot up the kernel that you want to stream line the config on.
#  2. Change directory to the directory holding the source of the
#       kernel that you just booted.
#  3. Copy the configuration file to this directory as .config
#  4. Have all your devices that you need modules for connected and
#      operational (make sure that their corresponding modules are loaded)
#  5. Run this script redirecting the output to some other file
#       like config_strip.
#  6. Back up your old config (if you want too).
#  7. copy the config_strip file to .config
#  8. Run "make oldconfig"
#
#  Now your kernel is ready to be built with only the modules that
#  are loaded.
#
# Here's what I did with my Debian distribution.
#
#    cd /usr/src/linux-2.6.10
#    cp /boot/config-2.6.10-1-686-smp .config
#    ~/bin/streamline_config > config_strip
#    mv .config config_sav
#    mv config_strip .config
#    make oldconfig
\end{lstlisting}

Na początku skopiowano plik \verb*|.config| do aktualnego katalogu roboczego.
\begin{figure}[H]
	\centering
	\includegraphics[width=15cm]{3_1}
	\caption{Kopiowanie pliku .config}
\end{figure}

Kolejno wykonano skrypt \verb*|streamline_config.pl| przekazując go do pliku \verb*|config_strip| zgodnie z instrukcją.
\begin{figure}[H]
	\centering
	\includegraphics[width=15cm]{3_2}
	\caption{Wykonanie skryptu streamline\_config.pl}
\end{figure}

Stworzono plik \verb*|.config.bak| będący kopią zapasową pliku \verb*|.config|.
\begin{figure}[H]
	\centering
	\includegraphics[width=15cm]{3_3}
	\caption{Kopiowanie pliku .config - kopia zapasowa}
\end{figure}

Podmieniono wcześniej utworzony plik \verb*|config_strip| z plikiem \verb*|.config|.
\begin{figure}[H]
	\centering
	\includegraphics[width=15cm]{3_4}
	\caption{Podmiana pliku config\_strip}
\end{figure}

Kolejno, zgodnie z zaleceniami, wywołano komendę \verb*|make oldconfig|. W przypadku ponad 50 zapytań o parametr wskazano wartość domyślną klawiszem \verb*|ENTER|.
\begin{figure}[H]
	\centering
	\includegraphics[width=15cm]{3_5}
	\caption{Wywołanie komendy make oldconfig}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=15cm]{3_6}
	\caption{Rezultat końcowy komendy make oldconfig}
\end{figure}

Wykonano komendę \verb*|make bzImage| kompilującą jądro.
\begin{figure}[H]
	\centering
	\includegraphics[width=15cm]{3_7}
	\caption{Wywołanie kompilacji jądra}
\end{figure}

Po niespełna 15 minutach ukończono kompilację z powodzeniem.
\begin{figure}[H]
	\centering
	\includegraphics[width=15cm]{3_8}
	\caption{Zakończenie kompilacji jądra}
\end{figure}

Przystąpiono do kompilacji modułów z wykorzystaniem komendy \verb*|make modules|.
\begin{figure}[H]
	\centering
	\includegraphics[width=15cm]{3_9}
	\caption{Wywołanie kompilacji modułów}
\end{figure}

Po około 2 minutach kompilacja modułów zakończyła się powodzeniem.
\begin{figure}[H]
	\centering
	\includegraphics[width=15cm]{3_10}
	\caption{Zakończenie kompilacji modułów}
\end{figure}

Kolejnym etapem było kopiowanie plików nowego jądra do katalogu boot z użyciem poniższych komend:
\begin{itemize}
	\item obraz jądra: \verb*|cp arch/x86/boot/bzImage /boot/vmlinuz-method2-5.18.3-smp|
	\item plik konfiguracyjny: \verb*|cp .config /boot/config-method2-5.18.3-smp|
	\item tablica symboli: \verb*|cp System.map /boot/System.map-method2-5.18.3-smp|
\end{itemize}
gdzie \verb*|method2| jest oznaczeniem aktualnie wykonywanej metody kompilacji jądra, a \verb*|5.18.3-smp| wersją jądra.
\begin{figure}[H]
	\centering
	\includegraphics[width=15cm]{3_11}
	\caption{Kopiowanie plików jądra do katalogu /boot}
\end{figure}

Kolejno, po otworzeniu katalogu \verb*|\boot|, skasowano stary plik \verb*|System.map| oraz utworzono odpowiedni link symboliczny.
\begin{figure}[H]
	\centering
	\includegraphics[width=15cm]{3_12}
	\caption{Tworzenie linku symbolicznego do System.map}
\end{figure}

Następnie wygenerowano stosowną komendę do utworzenia RAMDISK, którą wykonano modyfikując nazwę pliku na taką, która zachowa spójność ze wcześniejszymi plikami - dodano nazwę metody oraz wersję jądra.
\begin{figure}[H]
	\centering
	\includegraphics[width=15cm]{3_13}
	\caption{Tworzenie RAMDISK}
\end{figure}

Kolejnym etapem było dodanie wpisu do pliku \verb*|/etc/lilo.conf|.
\begin{figure}[H]
	\centering
	\includegraphics[width=15cm]{3_14}
	\caption{Edycja lilo.conf}
\end{figure}

Po zmodyfikowania wcześniej wspomnianego pliku, zatwierdzono zmiany wywołując komendę \verb*|lilo|.
\begin{figure}[H]
	\centering
	\includegraphics[width=15cm]{3_15}
	\caption{Zatwierdzenie zmian w LILO}
	\label{error}
\end{figure}

Przy rebootowaniu systemu wbrew oczekiwaniom nie ukazała sie dostępna opcja \verb*|method2|. Po krótkiej analizie dotychczasowej dokumentacji (zrzutów ekranu) udało się zidentyfikować błąd: na zrzucie \ref{error} na standardowym wyjściu pojawiła się informacja o braku pliku \verb*|/boot/initrd-method2-5.18.3-smp|. W celu szerszego rozpoznania błędu i naprawy wykonano następujące czynności:
\begin{itemize}
	\item Sprawdzono, czy prawidłowa ścieżka znajduje się w pliku lilo.conf
	\item Wylistowano katalog \verb*|/boot| - zauważono błędną nazwę pliku \verb*|initrd|
	\item Zmieniono nazwę pliku \verb*|initrd| na poprawną
	\item Powtórnie wykonano komendę \verb*|lilo|
\end{itemize}
\begin{figure}[H]
	\centering
	\includegraphics[width=15cm]{3_16}
	\caption{Naprawa błędu}
\end{figure}

Po poprawieniu błędu przystąpiono ponownie do rebootu systemu. Tym razem w boot menu ukazała się etykieta \verb*|method2|.
\begin{figure}[H]
	\centering
	\includegraphics[width=15cm]{3_17}
	\caption{Boot menu}
\end{figure}

Udało się pomyślnie zalogować do systemu oraz została wyświetlona informacja o wersji jądra.
\begin{figure}[H]
	\centering
	\includegraphics[width=15cm]{3_18}
	\caption{Pomyślne logowanie do systemu}
\end{figure}

Stworzono archiwum \verb*|method2.zip| zawierające pliki jądra dla drugiej metody. Pliki zostały skopiowane do innego systemu analogicznie do sposobu zaprezentowanego w rozdziale z pierwszą metodą kompilacji jądra.
\begin{figure}[H]
	\centering
	\includegraphics[width=15cm]{3_19}
	\caption{Tworzenie archiwum}
\end{figure}


\end{document}          
